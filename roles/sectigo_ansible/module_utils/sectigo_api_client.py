#!/usr/bin/python
# -*- coding: utf-8 -*-
import os.path
import sys
import requests
import json
import time
import logging
import inspect

# -------------------------------- #
# sectigo_pycert Version: v1.0.1.0 #
# -------------------------------- #

from os.path import exists, join, isdir
from datetime import datetime
from OpenSSL import crypto as c
from cryptography.hazmat.primitives import hashes

from OpenSSL.crypto import _lib, _ffi, X509

from logging.handlers import RotatingFileHandler

python_version = "3"
if sys.version_info[0] < 3:
    python_version = "2"

# Variables
error_resp = {}

cert_csr_handler = ''
cert_csr_name = ''
cert_crt_name = ''
cert_key_name = ''
cert_ids_name = ''

# Initialize Logger and the configuration
logger = logging.getLogger("entrypointlog")
formatter = logging.Formatter('%(asctime)s | %(name)s | %(levelname)s: %(message)s')
logger.setLevel(logging.DEBUG)

# Define Handlers for Logs - Stream Handler
stream_handler = logging.StreamHandler()
stream_handler.setLevel(logging.ERROR)
stream_handler.setFormatter(formatter)

# Define Handlers for Logs - Logfile Handler
logFilePath = "entrypoint_script.log"
file_handler = RotatingFileHandler(filename=logFilePath, maxBytes=15000000, backupCount=15)
file_handler.setLevel(logging.DEBUG)
file_handler.setFormatter(formatter)

# Add the Handlers to Logger for various types of Logging 
logger.addHandler(file_handler)
logger.addHandler(stream_handler)

cert_resource_data_file = "sectigo_resource_data.txt"

logger.debug(python_version)

# Names of parameters passed to the Python libraries from Ansible for different certificate
# related resources (operations). These parameter names are used for validation purposes.
operation_parameters = {
    'SECT_ENROLL_SSL_CERT': [
        'login', 'customerUri', 'password', 'orgId', 'subjAltNames', 'certType', 'force',
        'numberServers', 'serverType', 'term', 'comments', 'customFields', 'externalRequester',
        'sectCABaseUrl', 'certFilePath', 'certFileName', 'expiryWindow', 'autoRenew'
    ],
    'SECT_ENROLL_SSL_CERT_EXCL': ['comments', 'externalRequester', 'subjAltNames', 'numberServers', 'customFields',
                                  'certDomain'],
    'SECT_COLLECT_SSL_CERT': [
        'login', 'customerUri', 'password', 'sslId', 'formatType', 'maxTimeout', 'loopPeriod',
        'sectCABaseUrl', 'certFilePath', 'certFileName'
    ],
    'SECT_REVOKE_SSL_CERT': [
        'login', 'customerUri', 'password', 'sslId', 'reason', 'sectCABaseUrl'
    ],
    'SECT_ENROLL_CLIENT_CERT': [
        'login', 'customerUri', 'password', 'orgId', 'certType', 'force', 'email',
        'firstName', 'middleName', 'lastName', 'term', 'customFields',
        'sectCABaseUrl', 'certFilePath', 'certFileName', 'expiryWindow', 'autoRenew'
    ],
    'SECT_COLLECT_CLIENT_CERT': [
        'login', 'customerUri', 'password', 'orderNumber', 'maxTimeout', 'loopPeriod',
        'sectCABaseUrl', 'certFilePath', 'certFileName'
    ],
    'SECT_REVOKE_CLIENT_CERT': [
        'login', 'customerUri', 'password', 'orderNumber', 'reason', 'sectCABaseUrl'
    ],
    'SECT_CSR_DATA': [
        'C', 'CN', 'L', 'O', 'ST', 'emailAddress', 'OU'
    ]
}


class SectigoException(Exception):

    def __init__(self, api_json, *args, **kwargs):
        """
        Sectigo Exception Constructor
        Provides details on an exception generated by the API client
        :param api_json: A JSON representation of the error. It consists of `description` and `code`.
        """
        super(SectigoException, self).__init__(*args)
        self._error_details = json.loads(api_json)

    def error_dictionary(self):
        """
        Provides a dictionary representing the JSON document
        :return:
        """
        return self._error_details


class PKCS7EX(c.PKCS7):

    def __init__(self, parent):
        self.parent = parent

    def get_certificates(self):
        """
        Returns all certificates for the PKCS7 structure, if present. Only
        objects of type ``signedData`` or ``signedAndEnvelopedData`` can embed
        certificates.
        :return: The certificates in the PKCS7, or :const:`None` if
            there are none.
        :rtype: :class:`tuple` of :class:`X509` or :const:`None`
        """
        certs = _ffi.NULL

        if self.parent.type_is_signed():
            certs = self.parent._pkcs7.d.sign.cert

        elif self.parent.type_is_signedAndEnveloped():
            certs = self.parent._pkcs7.d.signed_and_enveloped.cert

        pycerts = []

        for i in range(_lib.sk_X509_num(certs)):
            x509 = _ffi.gc(_lib.X509_dup(_lib.sk_X509_value(certs, i)),
                           _lib.X509_free)

            pycert = X509._from_raw_x509_ptr(x509)

            pycerts.append(pycert)

        if pycerts:
            return tuple(pycerts)

    def get_certificate(self):
        """
        Returns only the certificate included in the bundle
        :return: The certificate in teh PKCS7 or :const:`None` if there are none.
        :rtype: A :class:`X509` object representing the certificate inside the pkcs7 file or :const:`None`
        """
        certs = self.get_certificates()
        for cert in certs:
            cert_data = c.dump_certificate(c.FILETYPE_TEXT, cert)
            if b'CA:TRUE' in cert_data:
                continue
            else:
                return cert


def log_error_resp(code, description):
    """
    Log an error message and print it to the console. In addition, add the
    error message to the response that will be returned when the currently
    running certificate operation is completed.

    param, code        - error code (if provided)
    param, description - error message
    """
    global error_resp
    if description:
        logger.error("line " + str(inspect.stack()[1][2]) + ": " + description)
    else:
        logger.error(
            "line " + str(inspect.stack()[1][2]) + ": " + "No error description received from Sectigo REST API")

    error_resp["code"] = code
    error_resp["description"] = description


def get_config_data(file_name):
    """
    Read config data from parameter files (if defined)

    param, file_name - parameter file name

    return - a dictionary containing parameters from the file
    """
    cert_gen_params = {}

    open_file = open(file_name)  # open file

    for line in open_file:
        line = line.replace('"', '')
        line = line.replace("'", "")
        line = line.rstrip()

        if (line != "") and (line[0] != "#"):

            if line[len(line) - 1] != "=":
                item = [i.strip() for i in line.split(' = ')]
            else:
                item = [i.strip() for i in line.split(' =')]

            if item[0] in cert_gen_params:
                continue
            else:
                cert_gen_params[item[0]] = item[1]

    return cert_gen_params


def get_subject_params(cert_oper_params):
    """
    Get a list of subject parameters used to generate content for the certificate CRS file.

    param, cert_oper_params - parameters for the current certificate operation

    return - a dictionary containing subject parameters
    """
    # Skip check if certSubject is null or empty
    subject_content = cert_oper_params["certSubject"]

    subject_content = subject_content.replace('"', '')
    subject_content = subject_content.replace("'", "")

    #    subject_content = subject_content.replace("<DOMAIN_NAME>",
    #                                              cert_oper_params["certDomain"])

    subject_content_array = subject_content.split("/")

    cert_subject_params = {}

    for line in subject_content_array:
        item = [line_item.strip() for line_item in line.split('=')]
        cert_subject_params[item[0]] = item[1]

    return cert_subject_params


def get_param_name_list(operation):
    """
    Get a list of parameter names required for a given certificate operation.

    param, operation - certification operation for which parameter names are obtained

    return - list of parameters for a given certification operation
    """
    return operation_parameters[operation]


def are_required_param_names_defined(operation, param_dict):
    """
    Check if all parameter names for a given certification operation defined in the
    dictionary passed to this function are also defined in the 'certResourceDataFile'
    file. Parameters are defined in the dictionary as:
    <key=cert param name, value=cert param value>.

    param, operation  - certification operation for which parameter names are checked
    param, param_dict - dictionary that contains parameter names as its keys

    return -  True  - all parameter names are defined
              False - otherwise
    """
    are_defined = False

    # Get a list of requested parameter names from the 'certResourceDataFile' file
    file_param_name_list = get_param_name_list(operation)

    # Get a list of parameter names (keys) from the input parameter dictionary
    dict_param_name_list = list(param_dict.keys())

    # Check if all parameter names defined in the received dictionary are
    # also defined in the 'certResourceDataFile' file
    result = all(item in dict_param_name_list for item in file_param_name_list)

    if result:
        are_defined = True
    else:
        # Let's find the missing parameter and report it
        for file_item in file_param_name_list:
            for input_item in dict_param_name_list:
                if file_item == input_item:
                    break
            else:
                raise ValueError("Missing input parameter: {0}".format(str(file_item)))

    return are_defined


def are_required_param_values_defined(param_dict, param_excl_list=None):
    """
    Check if parameter <key, value> pairs defined in the dictionary passed to this
    function have keys and values that are not empty strings. The exception are
    parameters that might be defined in a list of optional 'key' values
    (certification parameter names) passed in a separate list to this function.

    param, param_dict      - dictionary that contains parameter <key, value>
                             pairs to be checked
    param, param_excl_list - list of certification parameter names that are excluded
                             from the check

    return -  True  - all parameter keys and values have valid values
              False - otherwise
    """
    are_defined = True

    for key in param_dict:

        if ((param_excl_list is not None)
                and (key not in param_excl_list)
                and ((key == "") or (param_dict[key] == ""))):
            # are_defined = False
            raise ValueError("{0} is required but it has not been defined".format(key))

    return are_defined


def are_required_params_valid(operation, param_dict, param_excl_list=None):
    """
    Check if parameter <key, value> pairs for a given certification operation defined
    in the dictionary passed to this function have keys and values that are not empty
    strings. The exception are parameters that might be defined in a list of optional
    'key' values (certification parameter names) passed in a separate list to this
    function.

    param, operation       - certification operation for which parameter names
                             are checked
    param, param_dict      - dictionary that contains parameter <key, value>
                             pairs to be checked
    param, param_excl_list - list of certification parameter names that are excluded
                             from the check

    return -  True  - all parameter keys and values have valid values
              False - otherwise
    """
    if ((are_required_param_names_defined(operation,
                                          param_dict) is True)
            and (are_required_param_values_defined(param_dict,
                                                   param_excl_list) is True)):
        return True

    return False


def does_file_exist(file_path, file_name):
    """
    Check if a given file exists on a given file path.

    param, file_path - full file path
    param, file_name - file name

    return -  True  - file exists
              False - otherwise
    """
    file_full_path = join(file_path, file_name)

    if isdir(file_path):

        if exists(file_full_path):
            logger.info("Reading file: " + str(file_full_path))
            return True

        else:
            logger.info("File " + str(file_full_path) + " not found...")
            return False

    else:
        logger.info("File path " + str(file_path) + " not found...")
        return False


def are_enroll_ssl_cert_params_valid(cert_oper_params):
    """
    Check if parameters for the Enroll SSL certificate operation are valid.

    param, cert_oper_params - parameters for SSL certificate Enroll operation

    return -  True  - parameters are valid
              False - otherwise
    """
    if ((are_required_params_valid("SECT_ENROLL_SSL_CERT",
                                   cert_oper_params,
                                   get_param_name_list("SECT_ENROLL_SSL_CERT_EXCL")) is True)
            and (are_required_params_valid("SECT_CSR_DATA",
                                           get_subject_params(cert_oper_params)) is True)):
        return True

    return False


def are_collect_ssl_cert_params_valid(cert_oper_params):
    """
    Check if parameters for the Collect SSL certificate operation are valid.

    param, cert_oper_params - parameters for SSL certificate Collect operation

    return -  True  - parameters are valid
              False - otherwise
    """
    are_valid = False

    if (are_required_params_valid("SECT_COLLECT_SSL_CERT",
                                  cert_oper_params) is True):
        are_valid = True

    return are_valid


def are_revoke_ssl_cert_params_valid(cert_oper_params):
    """
    Check if parameters for the Revoke SSL certificate operation are valid.

    param, cert_oper_params - parameters for SSL certificate Revoke operation

    return -  True  - parameters are valid
              False - otherwise
    """
    are_valid = False

    if (are_required_params_valid("SECT_REVOKE_SSL_CERT",
                                  cert_oper_params) is True):
        are_valid = True

    return are_valid


def are_enroll_client_cert_params_valid(cert_oper_params):
    """
    Check if parameters for the Enroll Client certificate operation are valid.

    param, cert_oper_params - parameters for Client certificate Enroll operation

    return -  True  - parameters are valid
              False - otherwise
    """
    are_valid = False

    if ((are_required_params_valid("SECT_ENROLL_CLIENT_CERT",
                                   cert_oper_params) is True)
            and (are_required_params_valid("SECT_CSR_DATA",
                                           get_subject_params(cert_oper_params)) is True)):
        are_valid = True

    return are_valid


def are_collect_client_cert_params_valid(cert_oper_params):
    """
    Check if parameters for the Collect Client certificate operation are valid.

    param, cert_oper_params - parameters for Client certificate Collect operation

    return -  True  - parameters are valid
              False - otherwise
    """
    are_valid = False

    if (are_required_params_valid("SECT_COLLECT_CLIENT_CERT",
                                  cert_oper_params) is True):
        are_valid = True

    return are_valid


def are_revoke_client_cert_params_valid(cert_oper_params):
    """
    Check if parameters for the Revoke Client certificate operation are valid.

    param, cert_oper_params - parameters for Client certificate Revoke operation

    return -  True  - parameters are valid
              False - otherwise
    """
    are_valid = False

    if (are_required_params_valid("SECT_REVOKE_CLIENT_CERT",
                                  cert_oper_params) is True):
        are_valid = True

    return are_valid


def get_remaining_cert_validity(cert):
    """
    Get a number of remaining days before the certficate's expiry date.

    param, cert - certificate

    return -  number of remaining days before expiry
    """
    if python_version == "3":
        expires = datetime.strptime(str(cert.get_notAfter(), 'utf-8'), "%Y%m%d%H%M%SZ")
    else:
        expires = datetime.strptime(cert.get_notAfter(), "%Y%m%d%H%M%SZ")

    logger.debug("Expires: {}".format(expires))
    logger.debug("UTC Now: {}".format(datetime.utcnow()))
    remaining = (expires - datetime.utcnow()).days
    logger.debug("Remaining: {}".format(remaining))
    return remaining


def collect_x509_format_type_cert(cert_oper_params):
    """
    Collect a certificate that has the same sslId as the one defined in the
    IDS file (if exists) and that is in the X509 format.

    param, cert_oper_params - parameters for certificate Enroll operation =
    """
    global cert_crt_name
    global cert_ids_name

    cert_file_path = cert_oper_params["certFilePath"]
    cert_ids_name = cert_oper_params["certFileName"] + ".ids"

    # Get the IDS certificate file full path name
    ids_file_full_path = join(cert_file_path, cert_ids_name)

    # Make sure that the IDS file exists
    if not exists(ids_file_full_path):
        log_error_resp("", "Cannot collect x509 certificate, IDs file doesn't exist")
        raise SectigoException(json.dumps(error_resp))

    # Get sslId from the IDS file
    with open(ids_file_full_path, 'rb') as file:
        json_data = file.read()

        # Convert to a dictionary
        dict_data = json.loads(json_data)

        if "sslId" not in dict_data:
            log_error_resp("", "Cannot collect x509 certificate, sslId not defined in IDs file")
            raise SectigoException(json.dumps(error_resp))

            # Modify the name of the x509 certificate file that will be collected to a temporary value
    cert_oper_params["certFileName"] = cert_oper_params["certFileName"] + "_x509"

    # Set the 'sslId' and 'formatType' parameter values
    cert_oper_params["sslId"] = dict_data["sslId"]
    cert_oper_params["formatType"] = "x509CO"

    # Define the x509 certificate Collect request URL
    collect_request_url = """{sectCABaseUrl}/collect/{sslId}/{formatType}""".format(**cert_oper_params)

    # Define error codes returned by the Sectigo server that are valid for waiting during Collect
    valid_waiting_err_codes = [0, -1400]

    response = collect_cert(cert_oper_params, collect_request_url, valid_waiting_err_codes)

    if (('description' not in error_resp)
            and (response is not None)
            and (response.status_code >= 200)
            and (response.status_code < 300)):

        # Success
        return

    elif ('description' not in error_resp) and (response is None):
        log_error_resp("", "Unknown x509 certificate Collect error occurred.")
        raise SectigoException(json.dumps(error_resp))

    elif ('description' in error_resp) and (response is not None):
        err_msg = "x509 certificate Collect error: error_resp={0}, response={1}, status_code={2}".format(
            error_resp, response, response.status_code)
        log_error_resp("", err_msg)
        raise SectigoException(json.dumps(error_resp))

    else:
        log_error_resp("", "x509 certificate Collect error: error_resp={0}".format(error_resp))
        raise SectigoException(json.dumps(error_resp))


def check_cert_validity(cert_oper_params, cert_file_name):
    """
    Validate a given certificate validity and expiry date.

    param, cert_oper_params      - parameters for certificate Enroll operation =
    param, cert_file_name        - certificate file name

    return -  0 - valid certificate exists
              1 - valid certificate exists, but expired
             -1 - encountered an error while validating certificate
    """

    global cert_crt_name
    remaining = 90000

    try:
        cert_file_full_path = join(cert_oper_params['certFilePath'], cert_file_name)

        with open(cert_file_full_path, 'rb') as file:
            crt_file_full_path_data = file.read()

            # if 'formatType' in cert_oper_params
            # Check if this is a server certificate
            if 'email' not in cert_oper_params:
                logger.debug("Server certificate")

                # The certificate might be of the 'base64' or 'bin' format type,
                # therefore it might be unreadable. We have to collect a certificate
                # with the same sslId, but in the X509 format so that we can
                # read the file.

                # Save the 'formatType' parameter, to be restored later
                format_type_orig = cert_oper_params["formatType"]

                # Let's try to collect the certificate. This function will modify
                # the 'certFileName' parameter which needs to be restored as well.
                collect_x509_format_type_cert(cert_oper_params)

                # The 'certFileName' parameter has the modified value at this point
                x509_cert_file_full_path = join(cert_oper_params['certFilePath'],
                                                cert_oper_params['certFileName'])

                x509_cert_file_full_path = x509_cert_file_full_path + ".crt"

                # Restore modified parameter values
                cert_oper_params["formatType"] = format_type_orig
                cert_oper_params["certFileName"] = cert_file_name
                cert_crt_name = cert_file_name

                # Let's try to get 'remaining' from the x509
                # certification file that we just downloaded
                with open(x509_cert_file_full_path, 'rb') as validation_file:
                    x509_crt_file_data = validation_file.read()

                    cert = c.load_certificate(c.FILETYPE_PEM, x509_crt_file_data)
                    remaining = get_remaining_cert_validity(cert)

                # Delete the temporary certificate file
                os.remove(x509_cert_file_full_path)

            else:
                logger.debug("Client certificate")
                pkcs7 = PKCS7EX(c.load_pkcs7_data(c.FILETYPE_PEM, crt_file_full_path_data))

                cert = pkcs7.get_certificate()

                logger.info("Common name in certificate: {}".format(cert.get_subject().commonName))
                logger.info('Valid until: {}'.format(cert.get_notAfter()))

                remaining = get_remaining_cert_validity(cert)

    except Exception as err:
        log_error_resp("", "Error validating certificate: {}".format(err))
        raise

    else:
        logger.info("Remaining days " + str(remaining) + ", expiry window " + str(cert_oper_params["expiryWindow"]))

        if remaining < 1:
            logger.info(
                "ALERT !!! Valid certificate exists, but it has expired. Proceeding to generate a new certificate ... ")
            return 1

        elif remaining <= int(cert_oper_params["expiryWindow"]):
            logger.warning(
                "ALERT !!! Valid certificate exists and will expire in only " + format(
                    remaining) + " days. Proceeding to generate a new certificate ... ")
            return 1

        elif str(remaining).strip() == "":
            log_error_resp("", "Unable to read the certificate validity.")
            return -1

        else:
            logger.info(
                "Valid certificate exists and is valid up to " + format(remaining) + " days. Hence exiting !!! ")
            return 0


def rename_cert_files(cert_oper_params):
    """
    Rename certification files (CRT, CRS, IDS, KEY) such that current date/time
    gets added to their names.
    """
    global cert_crt_name
    global cert_csr_name
    global cert_key_name
    global cert_ids_name

    cert_file_path = cert_oper_params["certFilePath"]

    # Get certificate files full path names
    crt_file_full_path = join(cert_file_path, cert_crt_name)
    key_file_full_path = join(cert_file_path, cert_key_name)
    csr_file_full_path = join(cert_file_path, cert_csr_name)
    ids_file_full_path = join(cert_file_path, cert_ids_name)

    try:
        # Get the current date/time 
        curr_date_time = datetime.now()

        date_time_prefix = curr_date_time.strftime("_%Y-%m-%d_%H:%M:%S")

        # Get certificate files full path names
        crt_file_full_path_new = join(cert_file_path, cert_crt_name + date_time_prefix)
        key_file_full_path_new = join(cert_file_path, cert_key_name + date_time_prefix)
        csr_file_full_path_new = join(cert_file_path, cert_csr_name + date_time_prefix)
        ids_file_full_path_new = join(cert_file_path, cert_ids_name + date_time_prefix)

        if exists(crt_file_full_path):
            os.rename(crt_file_full_path, crt_file_full_path_new)

        # if exists(key_file_full_path):
        #     os.rename(key_file_full_path, key_file_full_path_new)

        # if exists(csr_file_full_path):
        #     os.rename(csr_file_full_path, csr_file_full_path_new)

        if exists(ids_file_full_path):
            os.rename(ids_file_full_path, ids_file_full_path_new)

    except Exception as err:
        log_error_resp("", "Failed to rename certificate files: ".format(str(err)))
        raise


def generate_private_key(file_path, file_name):
    """
    Generate private key for a certificate request.

    param, file_path - certificate key file path
    param, file_name - certificate key file name

    return - certificate key if it was successfully generated
             None, otherwise
    """
    # Proceed with new certificate key generation.
    logger.info("No existing keys and certs found. Proceeding to generate new one!")
    logger.debug("Checking Cert Key Val : " + cert_key_name)

    cert_key = c.PKey()

    try:
        # Generate certification key
        cert_key.generate_key(c.TYPE_RSA, 2048)

        # Certificate key file full path
        cert_key_file_full_path = join(file_path, file_name)

        logger.debug("Certificate key file path : " + cert_key_file_full_path)

        # Open the certificate key file and write the key into it
        if python_version == "3":
            open(cert_key_file_full_path,
                 "wt").write(str(c.dump_privatekey(c.FILETYPE_PEM, cert_key), 'utf-8'))
        else:
            open(cert_key_file_full_path,
                 "wb").write(c.dump_privatekey(c.FILETYPE_PEM, cert_key))

    except Exception as err:
        log_error_resp("", "Error in certificate private key generation: {}".format(err))
        raise

    else:
        if exists(cert_key_file_full_path):
            logger.info("Certificate key file " + str(file_name) + " generated successfully.")
            return cert_key

        else:
            log_error_resp("", "Certificate key file " + str(file_name) + " not generated successfully.")
            return None


def get_private_key_from_file(cert_oper_params):
    """
    Get a private key from the KEY file. 
    
    param, cert_oper_params - certificate Enroll operation parameters
    
    return - private key
    """
    global cert_key_name

    # Get the full path name of the KEY file
    key_file_full_path = join(cert_oper_params['certFilePath'], cert_key_name)

    try:
        # Retrieve an existing private key from the KEY file                      
        with open(key_file_full_path, 'rb') as file:

            key_file_data = file.read()
            priv_key = c.load_privatekey(c.FILETYPE_PEM, key_file_data)

        logger.debug("Retrieved an existing private key from file")

    except Exception as err:
        log_error_resp("", "Unable to retrieve private key from file: {}".format(str(err)))
        raise

    return priv_key


def is_cert_csr_generated(cert_oper_params, file_path, file_name, cert_key):
    """
    Generate CSR for a certificate request (operation)

    param, cert_oper_params  - certificate parameter dictionary that contains
                               parameters required for this operation
    param, file_path         - certificate CSR file path
    param, file_name         - certificate CSR file name
    param, cert_key          - certificate key

    return - True,  certificate CSR was successfully generated
             False, otherwise
    """
    global cert_csr_name

    # Get full path name of the certificate CRS file
    cert_csr_file_full_path = join(file_path, file_name)
    # Check if the csr already exists
    if exists(cert_csr_file_full_path):
        logger.info("Certificate CSR file " + str(file_name) + " generated successfully.")
        return True

    # Proceed with new certificate CSR generation
    if 'certDomain' in cert_oper_params:
        log_msg = """
        Proceeding with Certificate CSR generation: {} (CN Name: {})
        """.format(cert_csr_name, cert_oper_params["certDomain"])
        logger.info(log_msg.strip())

    cert_subj_aliases = []

    cert_subject_params = get_subject_params(cert_oper_params)

    try:
        if cert_oper_params["certSubject"] != "":

            for val in cert_subject_params:
                logger.debug("Module Key : " + val + ", Value : " + cert_subject_params[val])

            aliases = cert_oper_params["certSubject"].split(",")

            if aliases:
                for alias in aliases:
                    cert_subj_aliases.append("DNS:{}".format(alias))

            # Generate a CSR          
            cert_csr = c.X509Req()
            cert_csr.get_subject().CN = cert_subject_params["CN"]
            cert_csr.get_subject().C = cert_subject_params["C"]
            cert_csr.get_subject().ST = cert_subject_params["ST"]
            cert_csr.get_subject().L = cert_subject_params["L"]
            cert_csr.get_subject().O = cert_subject_params["O"]
            cert_csr.get_subject().OU = cert_subject_params["OU"]
            cert_csr.get_subject().emailAddress = cert_subject_params["emailAddress"]
            cert_csr.set_pubkey(cert_key)

            if python_version == "3":
                logger.info(",".join(cert_subj_aliases))

                cert_subj_aliases_bytes = str.encode(",".join(cert_subj_aliases))
                subject_alt_name_bytes = str.encode('subjectAltName')

                cert_csr.add_extensions([c.X509Extension(subject_alt_name_bytes,
                                                         False,
                                                         cert_subj_aliases_bytes)])

            else:
                cert_csr.add_extensions([c.X509Extension("subjectAltName",
                                                         False,
                                                         ",".join(cert_subj_aliases))])

            cert_csr.sign(cert_key, hashes.SHA256().name)

            # Open the file
            open(cert_csr_file_full_path,
                 "wb+").write(c.dump_certificate_request(c.FILETYPE_PEM, cert_csr))

        else:
            # Generate a CSR
            cert_csr = c.X509Req()
            cert_csr.get_subject().CN = cert_subject_params["CN"]
            cert_csr.get_subject().C = cert_subject_params["C"]
            cert_csr.get_subject().ST = cert_subject_params["ST"]
            cert_csr.get_subject().L = cert_subject_params["L"]
            cert_csr.get_subject().O = cert_subject_params["O"]
            cert_csr.get_subject().OU = cert_subject_params["OU"]
            cert_csr.get_subject().emailAddress = cert_subject_params["emailAddress"]
            cert_csr.set_pubkey(cert_key)
            cert_csr.sign(cert_key, hashes.SHA256().name)

            # Open the file
            open(cert_csr_file_full_path,
                 "wb+").write(c.dump_certificate_request(c.FILETYPE_PEM, cert_csr))

    except Exception as err:
        log_error_resp("", "Error in certificate CSR generation: {}".format(err))
        raise

    else:
        if exists(cert_csr_file_full_path):
            logger.info("Certificate CSR file " + str(file_name) + " generated successfully.")
            return True

        else:
            log_error_resp("", "Certificate CSR file " + str(file_name) + " not generated successfully.")
            return False


def is_private_key_undefined_and_other_cert_files_defined(cert_oper_params):
    """
    Validate if we are in a scenario where the private key file is not defined and
    either CSR or/and CRT files are defined. In this case we will fail Enroll.
    
    param, cert_oper_params - certificate Enroll operation parameters
    
    return - True, necessary conditions are met
             False, otherwise
    """
    global cert_crt_name
    global cert_csr_name
    global cert_key_name
    global cert_ids_name

    # Check if certificate files exist
    does_cert_crt_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_crt_name)
    does_cert_csr_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_csr_name)
    does_cert_key_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_key_name)
    does_cert_ids_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_ids_name)

    if ((does_cert_key_file_exist is False)
            and (does_cert_crt_file_exist or does_cert_csr_file_exist)):

        file_msg = ""

        if does_cert_crt_file_exist:
            file_msg += cert_crt_name

        if does_cert_csr_file_exist:

            if file_msg != "":
                file_msg += " and "

            file_msg += cert_csr_name

        if does_cert_ids_file_exist:

            if file_msg != "":
                file_msg += " and "

            file_msg += cert_ids_name

        # We want to fail the Enroll operation in this scenario
        log_error_resp("", cert_key_name + " undefined while " + file_msg + " defined.")


def is_to_continue_with_enroll(cert_oper_params):
    """
    Validate if necessary criteria is met to start the certificate Enroll operation.

    param, cert_oper_params      - certificate Enroll operation parameters

    return - True, necessary conditions are met
             False, otherwise
    """
    global cert_crt_name
    global cert_csr_name
    global cert_key_name
    global cert_ids_name

    is_to_continue = False

    if cert_oper_params['force']:
        rename_cert_files(cert_oper_params)
        return True

    # Check if certificate already exists locally, else generate a new certificate
    does_cert_crt_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_crt_name)
    does_cert_key_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_key_name)
    does_cert_csr_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_crt_name)
    does_cert_ids_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_ids_name)

    if ((does_cert_key_file_exist is False)
            and (does_cert_crt_file_exist
                 or does_cert_csr_file_exist
                 or does_cert_ids_file_exist)):
        log_error_resp("", "Certificate key file undefined while other certificate files defined.")
        raise SectigoException(json.dumps(error_resp))

    if ((does_cert_crt_file_exist is False)
          and (does_cert_key_file_exist is False)
          and (does_cert_csr_file_exist is False)
          and (does_cert_ids_file_exist is False)):

        is_to_continue = True

    elif ((does_cert_key_file_exist is True)
          and (does_cert_ids_file_exist is True)):

        is_to_continue = False

    elif does_cert_key_file_exist:

        is_to_continue = True

    return is_to_continue


def auto_renew_and_update_cert(cert_oper_params, renew_request_url, renew_request_headers, renew_request_payload):
        logger.debug("auto_renew_and_update_cert has been called!")

        # Get the IDS certificate file full path name
        ids_file_full_path = join(cert_oper_params["certFilePath"], cert_ids_name)

        # Make sure that the IDS file exists
        if not exists(ids_file_full_path):
            log_error_resp("", "Cannot auto renew the certificate, IDs file doesn't exist" + ids_file_full_path)
            raise SectigoException(json.dumps(error_resp))

        # Get cert ID from the IDS file
        with open(ids_file_full_path, 'rb') as file:
            json_data = file.read()

            # Convert to a dictionary
            dict_data = json.loads(json_data)

            if "sslId" not in dict_data and "orderNumber" not in dict_data:
                log_error_resp("", "Cannot auto renew the certificate, the cert ID is not defined in IDs file")
                raise SectigoException(json.dumps(error_resp))


        # Append the cert ID to the url
        if 'email' not in cert_oper_params:
            renew_request_url = join(renew_request_url, str(dict_data['sslId']))
        else:
            renew_request_url = join(renew_request_url, str(dict_data['orderNumber']))

        # Renew the certificate
        logger.debug("--------------------- RENEWING CERT -----------------------")

        logger.debug("Renew certificate URL : " + renew_request_url)

        try:
            # Create a backup of the current files
            rename_cert_files(cert_oper_params)

            logger.debug("Posting payload: {0}".format(renew_request_payload))

            renew_response = requests.post(renew_request_url,
                                            headers=renew_request_headers,
                                            json=renew_request_payload)

            logger.debug(renew_response.json())

            renew_response.raise_for_status()

            return renew_response

        except requests.exceptions.RequestException as err:
            # TODO Possibly do further handling on the exception
            log_error_resp("", "Invalid Renew response. Error: {}".format(err))
            raise SectigoException(json.dumps(error_resp))

        except Exception as err:
            log_error_resp("", "Invalid Renew response. Error: {}".format(err))
            raise SectigoException(json.dumps(error_resp))


def prepare_csr_content_for_enroll_request(file_path, file_name):
    """
    Get CRS content for Enroll certificate requests

    param, file_path - certificate file path
    param, file_name  - name of CSR certificate related file

    return - CRS content from the file
    """
    # Get the full path CSR file name
    csr_file_full_path = join(file_path, file_name)

    # Get the CSR file content            
    with open(csr_file_full_path, 'r') as file_handle:
        csr_content = file_handle.read()

    csr_content = csr_content.replace('\n', '')  # remove new line char
    csr_content = csr_content.replace('--- ', '')  # begin certificate
    csr_content = csr_content.replace(' ---', '')  # end certificate

    return csr_content


def is_valid_collect_waiting_code(resp_code, valid_code_array):
    """
    Check if the collect Sectigo error return code is a valid code for waiting.

    param, resp_code        - Response error code received from Sectigo server
    param, valid_code_array - Array of valid error codes,
                              'None' if all error codes are valid

    return - True,  Sectigo error code is a valid waiting code
             False, Otherwise
    """
    if valid_code_array is None:
        # All return codes are considered valid
        return True

    if resp_code in valid_code_array:
        return True

    return False


def do_any_cert_files_exist(cert_oper_params):
    """
    Validate if at least one certificate file (CRT, CSR or KEY) exists. 
    
    param, cert_oper_params - certificate Enroll operation parameters
    
    return - True, necessary conditions are met
             False, otherwise
    """
    global cert_crt_name
    global cert_csr_name
    global cert_key_name
    global cert_ids_name

    # Check if certificate files exist
    does_cert_crt_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_crt_name)
    does_cert_csr_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_csr_name)
    does_cert_key_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_key_name)
    does_cert_ids_file_exist = does_file_exist(cert_oper_params["certFilePath"], cert_ids_name)

    if (does_cert_crt_file_exist
            or does_cert_csr_file_exist
            or does_cert_key_file_exist
            or does_cert_ids_file_exist):
        return True

    return False


def enroll_cert(enroll_cert_params,
                enroll_request_url,
                enroll_request_headers,
                enroll_request_payload):
    """
    Common function that processes a certificate Enroll request.

    param, enroll_certParams      - Enroll certificate parameters
    param, enroll_request_url     - URL for the Enroll request
    param, enroll_request_headers - headers for the Enroll request
    param, enroll_request_payload - payload for the Enroll request             - 

    return - Full Enroll requests response
    """
    enroll_response = None

    # Check if 'expiryWindow' is an integer and if it is at least 1
    try:
        exp_window = int(enroll_cert_params["expiryWindow"])

        if exp_window < 1:
            log_error_resp("", "expiryWindow must be at least 1 day.")
            return enroll_response

    except ValueError:
        log_error_resp("", "expiryWindow must be an integer.")
        return enroll_response

    global cert_crt_name
    global cert_csr_name
    global cert_key_name
    global cert_ids_name

    # Define certificate related file names
    cert_crt_name = enroll_cert_params["certFileName"] + ".crt"
    cert_csr_name = enroll_cert_params["certFileName"] + ".csr"
    cert_key_name = enroll_cert_params["certFileName"] + ".key"
    cert_ids_name = enroll_cert_params["certFileName"] + ".ids"

    # Check if new certificate needs to be generated    
    if is_to_continue_with_enroll(enroll_cert_params):

        cert_key = None

        does_cert_key_file_exist = does_file_exist(enroll_cert_params["certFilePath"], cert_key_name)

        if does_cert_key_file_exist:
            # Retrieve an existing private key from the KEY file 
            cert_key = get_private_key_from_file(enroll_cert_params)

        else:
            # Generate a new private key
            cert_key = generate_private_key(enroll_cert_params["certFilePath"], cert_key_name)

        if cert_key is None:
            return enroll_response

        if 'csr' in enroll_cert_params.keys():
            if not enroll_cert_params['csr']:
                raise ValueError("csr parameter cannot be null or empty: received csr={0}".format(
                    enroll_cert_params['csr']))

        does_csr_key_file_exist = does_file_exist(enroll_cert_params["certFilePath"], cert_csr_name)

        if not does_csr_key_file_exist:

            # Let's check if 'csr' is defined as a key
            if 'csr' not in enroll_cert_params.keys():

                if 'certSubject' not in enroll_cert_params:
                    log_error_resp("", "Either csr or certSubject must be defined as input parameters")
                    return enroll_response

                # CSR not provided. Generate it.
                if (is_cert_csr_generated(enroll_cert_params,
                                          enroll_cert_params["certFilePath"],
                                          cert_csr_name,
                                          cert_key) is False):
                    return enroll_response

                csr_content = prepare_csr_content_for_enroll_request(enroll_cert_params["certFilePath"],
                                                                     cert_csr_name)

                logger.info("CSR: " + csr_content)

                # Set the CSR value in the request payload passed to this function
                enroll_request_payload["csr"] = csr_content

            else:
                if os.path.exists(enroll_cert_params['csr']) and os.path.isfile(enroll_cert_params['csr']):

                    dirname_filename = os.path.split(enroll_cert_params['csr'])

                    enroll_request_payload['csr'] = prepare_csr_content_for_enroll_request(dirname_filename[0],
                                                                                           dirname_filename[1])

                else:
                    log_error_resp("", "CSR parameter value is not valid: {0}".format(enroll_cert_params['csr']))
                    raise SectigoException(json.dumps(error_resp))

            logger.debug("CSR: " + enroll_request_payload['csr'])

        else:
            enroll_request_payload['csr'] = prepare_csr_content_for_enroll_request(enroll_cert_params["certFilePath"],
                                                                                   cert_csr_name)

            # Check if certificate IDS file exist
        does_cert_ids_file_exist = does_file_exist(enroll_cert_params["certFilePath"], cert_ids_name)

        if does_cert_ids_file_exist:
            # Don't need to enroll if we already enrolled earlier
            return enroll_response

            # Enroll a certificate
        logger.debug("--------------------- ENROLLING CERT -----------------------")

        logger.debug("Enroll certificate URL : " + enroll_request_url)

        try:
            logger.debug("Posting payload: {0}".format(enroll_request_payload))

            enroll_response = requests.post(enroll_request_url,
                                            headers=enroll_request_headers,
                                            json=enroll_request_payload)

            logger.debug(enroll_response.json())

            enroll_response.raise_for_status()

        except requests.exceptions.RequestException as err:

            logger.error(err)

            if enroll_response is not None:
                dict_resp_content = json.loads(enroll_response.text)

                if ('code' in dict_resp_content) and ('description' in dict_resp_content):

                    log_error_resp(dict_resp_content['code'],
                                   dict_resp_content['description'])
                    raise SectigoException(json.dumps(error_resp))

                else:
                    log_error_resp(enroll_response.status_code,
                                   "Invalid Enroll response. Error: {}".format(err))
                    raise SectigoException(json.dumps(error_resp))

            else:
                log_error_resp("", "Invalid Enroll response. Error: {}".format(err))
                raise SectigoException(json.dumps(error_resp))

        except Exception as err:
            log_error_resp("", "Invalid Enroll response. Error: {}".format(err))
            raise SectigoException(json.dumps(error_resp))

    else:
        if 'description' not in error_resp:
            logger.debug("Valid certificate " + cert_crt_name + " already defined")

    return enroll_response


def collect_cert(collect_cert_params, collect_request_url, valid_codes=None):
    """
    Common function that processes a certificate Collect request.

    param, collect_cert_params - dictionary containing common certificate Collect
                                 parameters for all certificate type
    param, collect_request_url - Collect request URL that contains (in its path)
                                 specific certificate Collect parameters
    param, valid_codes         - array of valid Sectigo error response codes for waiting
                                 None if all codes are valid

    return - Requests response for the Collect operation
             None - if operation failed
    """
    global cert_crt_name

    cert_crt_name = collect_cert_params["certFileName"] + ".crt"

    collect_response = None

    try:
        collect_request_headers = {'login': collect_cert_params["login"],
                                   'password': collect_cert_params["password"],
                                   'customerUri': collect_cert_params["customerUri"]}

        logger.debug("Collect certificate URL: " + collect_request_url)

        cert_file_full_path = join(collect_cert_params["certFilePath"], cert_crt_name)

        collect_response = requests.get(collect_request_url,
                                        headers=collect_request_headers,
                                        allow_redirects=True)

        logger.debug("Collect Certificate Status Code: " + str(collect_response.status_code))
        logger.debug("Collect Certificate Content Type: " + str(collect_response.headers['content-type']))
        logger.debug("Collect Certificate Encoding: " + collect_response.encoding)

        max_timeout = collect_cert_params["maxTimeout"]
        loop_period = collect_cert_params["loopPeriod"]

        timer = 0

        # Loop over for response status = 400. If not, check if it's null or not 400 then do respective actions
        while ((collect_response.status_code != 200)
               or (collect_response.status_code is None)
               or (collect_response.status_code == "")):

            dict_resp_content = json.loads(collect_response.text)

            if ('code' in dict_resp_content) and ('description' in dict_resp_content):

                resp_code = dict_resp_content['code']
                resp_desc = dict_resp_content['description']

                # Check for the valid Sectigo response codes for waiting
                if ((valid_codes is not None)
                        and (is_valid_collect_waiting_code(int(resp_code), valid_codes) is False)):
                    log_error_resp(int(resp_code), resp_desc)
                    return collect_response

                logger.debug(
                    "Collect certificate, waiting... Response code " + str(resp_code) + ", " + str(resp_desc))

            else:
                logger.debug(
                    "Collect certificate. Status code " + str(collect_response.status_code) + ", waiting... ")

            if collect_response.status_code == 400:

                # If status code is 400, sleep for 29 seconds so that the loop runs less number of times                
                if timer >= max_timeout:

                    logger.info("Timed Out: " + str(timer) + " seconds out of " + str(max_timeout) + " seconds.")
                    log_error_resp(collect_response.status_code, "Timed out after {} seconds.".format(str(timer)))
                    # Timer exceeded the time-out period 
                    if python_version == "2":
                        logger.info("Collect certificate encoding : " + str(collect_response.content))

                    else:
                        logger.info("Collect certificate encoding : " + str(collect_response.content, 'utf-8'))
                    break

                else:
                    time.sleep(loop_period)

                    logger.debug("Collect certificate URL : " + collect_request_url)

                    collect_response = requests.get(collect_request_url,
                                                    headers=collect_request_headers,
                                                    allow_redirects=True)

                    timer = timer + loop_period

                    logger.info("Waiting... " + str(timer) + " seconds out of " + str(max_timeout) + " seconds.")

                    continue
            else:
                logger.debug("Inside If-Else - xxx Status Code")
                log_error_resp(collect_response.status_code, "Error in Collect certificate")
                break

        if collect_response.status_code == 200:
            try:
                with open(cert_file_full_path, 'wb') as file_handle:
                    file_handle.write(collect_response.content)

                logger.info(
                    "Sectigo certificate " + collect_cert_params["certFileName"] + " downloaded at " +
                    collect_cert_params[
                        "certFilePath"] + " successfully")

            except Exception as err:
                log_error_resp("", "Invalid Collect response: {}".format(err))

            return collect_response

        else:
            try:
                collect_response.raise_for_status()

            except requests.exceptions.RequestException as err:

                if collect_response is not None:
                    dict_resp_content = json.loads(collect_response.text)

                    if (('code' in dict_resp_content)
                            and ('description' in dict_resp_content)):

                        log_error_resp(dict_resp_content['code'],
                                       dict_resp_content['description'])

                    else:
                        log_error_resp(collect_response.status_code,
                                       "Invalid Collect response. Error: {}".format(err))

    except Exception as err:
        raise
        # log_error_resp(collect_response.status_code, "Error in Collect certificate: {}".format(err))

    return collect_response

def renew_cert(renew_cert_params,
               renew_request_url,
               renew_request_headers,
               renew_request_payload):
    """
    Common function that processes a certificate Renew request.

    param, renew_certParams      - Renew certificate parameters
    param, renew_request_url     - URL for the Renew request
    param, renew_request_headers - headers for the Renew request
    param, renew_request_payload - payload for the Renew request             - 

    return - Full Renew requests response
    """
    renew_response = None

    global cert_crt_name
    global cert_csr_name
    global cert_key_name
    global cert_ids_name

    # Define certificate related file names
    cert_crt_name = renew_cert_params["certFileName"] + ".crt"
    cert_csr_name = renew_cert_params["certFileName"] + ".csr"
    cert_key_name = renew_cert_params["certFileName"] + ".key"
    cert_ids_name = renew_cert_params["certFileName"] + ".ids"

    try:
        renew_response = auto_renew_and_update_cert(renew_cert_params, renew_request_url, renew_request_headers, renew_request_payload)
        return renew_response
    except Exception as err:
        raise
    



def revoke_cert(revoke_request_url, revoke_request_headers, revoke_request_payload):
    """
    Common function that processes a certificate Revoke request.

    param, revoke_request_url     - URL for the Revoke request
    param, revoke_request_headers - headers for the Revoke request
    param, revoke_request_payload - payload for the Revoke request

    return - Requests response for the Revoke operation
             None - if operation failed
    """
    revoke_response = None

    try:

        logger.debug("Revoke certificate URL : " + revoke_request_url)

        revoke_response = requests.post(revoke_request_url,
                                        headers=revoke_request_headers,
                                        json=revoke_request_payload)
        # else:
        #     revoke_response = requests.post(revoke_request_url,
        #                                     headers=revoke_request_headers,
        #                                     data=json.dumps(revoke_request_payload))

        revoke_response.raise_for_status()

    except requests.exceptions.RequestException as err:

        if revoke_response is not None:
            dict_resp_content = json.loads(revoke_response.text)

            if ('code' in dict_resp_content) and ('description' in dict_resp_content):

                log_error_resp(dict_resp_content['code'],
                               dict_resp_content['description'])

            else:
                log_error_resp(revoke_response.status_code,
                               "Invalid Revoke response. Error: {}".format(err))

        else:
            log_error_resp("",
                           "Invalid Revoke response. Error: {}".format(err))

        logger.debug("Certificate not revoked : " + str(revoke_response.content))

    except Exception as err:

        log_error_resp("", "Invalid Revoke response. Error: {}".format(err))
        logger.debug("Certificate not revoked : " + str(revoke_response.content))

    return revoke_response


def sect_enroll_ssl_cert(cert_oper_params):
    """
    API used to trigger the 'Enroll SSL certificate' operation.

    param, cert_oper_params - certificate parameter dictionary that contains
                            parameters required for this operation

    return - Requests response for the Collect operation
             None - if operation failed
    """
    global cert_ids_name
    global error_resp
    error_resp = {}

    logger.info("Proceeding to enroll SSL certificate...")

    do_parameter_validation = True

    # Get full path name of the csr if defined
    if 'csr' in cert_oper_params.keys() and cert_oper_params['csr'] and exists(cert_oper_params['csr']):
        do_parameter_validation = False

    try:
        if do_parameter_validation:
            if not are_enroll_ssl_cert_params_valid(cert_oper_params):
                raise ValueError('Enroll parameter validation failed')

        # Proceed with new Sectigo certificate Enroll request
        enroll_request_url = join(cert_oper_params["sectCABaseUrl"], str('enroll'))

        enroll_request_headers = {
            'login': cert_oper_params["login"],
            'password': cert_oper_params["password"],
            'customerUri': cert_oper_params["customerUri"]
        }

        enroll_request_payload = {
            'orgId': cert_oper_params["orgId"],
            'csr': "",
            'certType': cert_oper_params["certType"],
            'numberServers': cert_oper_params["numberServers"],
            'serverType': cert_oper_params["serverType"],
            'term': cert_oper_params["term"],
            'comments': cert_oper_params["comments"],
            'externalRequester': cert_oper_params["externalRequester"],
            'subjAltNames': cert_oper_params["subjAltNames"]
        }

        response = enroll_cert(cert_oper_params,
                               enroll_request_url,
                               enroll_request_headers,
                               enroll_request_payload)

        if (('description' not in error_resp)
                and (response is not None)
                and (response.status_code >= 200)
                and (response.status_code < 300)):

            # Success
            pyth_resp_content = json.loads(response.text)
            cert_sslid = pyth_resp_content["sslId"]

            logger.info("Enroll SSL certificate request successfully completed [sslId = " + str(cert_sslid) + "]")

            return response.text

        elif ('description' not in error_resp) and (response is None):
            # Valid certificate already exists, return its sslId and renewId from the IDS file
            cert_ids_file_full_path = join(cert_oper_params['certFilePath'], cert_ids_name)

            with open(cert_ids_file_full_path, 'r') as file:

                json_data = file.read()

                # Convert to a dictionary
                dict_data = json.loads(json_data)

                if "name" in dict_data:
                    # Remove the 'name' item
                    dict_data.pop("name")

                    # Convert back to JSON
                    json_data = json.dumps(dict_data)

            return str(json_data)

        elif ('description' in error_resp) and (response is not None):
            err_msg = "Enroll error: error_resp={0}, response={1}, status_code={2}".format(
                error_resp, response, response.status_code)
            log_error_resp("", err_msg)
            raise SectigoException(json.dumps(error_resp))

        else:
            log_error_resp("", "Enroll error: error_resp={0}".format(error_resp))
            raise SectigoException(json.dumps(error_resp))

    except Exception as err:
        log_error_resp("", "Enroll error occurred: {}".format(str(err)))
        raise


def sect_collect_ssl_cert(cert_oper_params):
    """
    API used to trigger the 'Collect SSL certificate' operation.

    param, cert_oper_params - certificate parameter dictionary that contains
                            parameters required for this operation

    return - Requests response for the Collect operation
             None - if operation failed
    """
    global error_resp
    error_resp = {}

    logger.info("Proceeding to collect SSL certificate...")

    try:
        # Check if provided parameters are valid
        if not are_collect_ssl_cert_params_valid(cert_oper_params):
            raise ValueError('Collect parameter validation failed')

        # Proceed with new Sectigo certificate Collect request
        collect_request_url = """{sectCABaseUrl}/collect/{sslId}/{formatType}""".format(**cert_oper_params)

        # Error codes returned by the Sectigo server that are valid for waiting
        valid_waiting_err_codes = [0, -1400]

        response = collect_cert(cert_oper_params, collect_request_url, valid_waiting_err_codes)

        if (('description' not in error_resp)
                and (response is not None)
                and (response.status_code >= 200)
                and (response.status_code < 300)):

            # Success
            cert_sslid = cert_oper_params["sslId"]

            logger.info("Collect SSL certificate request successfully completed [sslId = " + str(cert_sslid) + "]")

            return json.dumps({'certificate': response.text})

        elif ('description' not in error_resp) and (response is None):
            log_error_resp("", "Unknown Collect error occurred.")
            raise SectigoException(json.dumps(error_resp))

        elif ('description' in error_resp) and (response is not None):
            err_msg = "Collect error: error_resp={0}, response={1}, status_code={2}".format(
                error_resp, response, response.status_code)
            log_error_resp("", err_msg)
            raise SectigoException(json.dumps(error_resp))

        else:
            log_error_resp("", "Collect error: error_resp={0}".format(error_resp))
            raise SectigoException(json.dumps(error_resp))

    except Exception as err:
        log_error_resp("", "Collect error occurred: {}".format(str(err)))
        raise

def sect_renew_ssl_cert(cert_oper_params):
    """
    API used to trigger the 'Renew SSL certificate' operation.

    param, cert_oper_params - certificate parameter dictionary that contains
                            parameters required for this operation

    return - Requests response for the Collect operation
             None - if operation failed
    """
    global cert_ids_name
    global error_resp
    error_resp = {}

    logger.info("Proceeding to renew SSL certificate...")

    try:
        # Proceed with new Sectigo certificate Renew request
        renew_request_url = join(cert_oper_params["sectCABaseUrl"], str('renewById'))

        renew_request_headers = {
            'login': cert_oper_params["login"],
            'password': cert_oper_params["password"],
            'customerUri': cert_oper_params["customerUri"]
        }

        renew_request_payload = {
        }

        response = renew_cert(cert_oper_params,
                               renew_request_url,
                               renew_request_headers,
                               renew_request_payload)

        if (('description' not in error_resp)
                and (response is not None)
                and (response.status_code >= 200)
                and (response.status_code < 300)):

            # Success
            pyth_resp_content = json.loads(response.text)
            cert_sslid = pyth_resp_content["sslId"]

            logger.info("Renew SSL certificate request successfully completed [sslId = " + str(cert_sslid) + "]")

            return response.text

        elif ('description' in error_resp) and (response is not None):
            err_msg = "Renewal error: error_resp={0}, response={1}, status_code={2}".format(
                error_resp, response, response.status_code)
            log_error_resp("", err_msg)
            raise SectigoException(json.dumps(error_resp))

        else:
            log_error_resp("", "Renewal error: error_resp={0}".format(error_resp))
            raise SectigoException(json.dumps(error_resp))

    except Exception as err:
        log_error_resp("", "Renewal error occurred: {}".format(str(err)))
        raise

def sect_revoke_ssl_cert(cert_oper_params):
    """
    API used to trigger the 'Revoke SSL certificate' operation.

    param, cert_oper_params - certificate parameter dictionary that contains
                              parameters required for this operation

    return - Requests response for the Revoke operation
             None - if operation failed
    """
    global error_resp
    error_resp = {}

    logger.info("Proceeding to revoke SSL certificate...")

    try:
        # Check if provided parameters are valid
        if not are_revoke_ssl_cert_params_valid(cert_oper_params):
            raise ValueError('Revoke parameter validation failed')

        # Proceed with new Sectigo certificate Revoke request
        revoke_request_url = """{sectCABaseUrl}/revoke/{sslId}""".format(**cert_oper_params)

        revoke_request_headers = {
            'login': cert_oper_params["login"],
            'password': cert_oper_params["password"],
            'customerUri': cert_oper_params["customerUri"]
        }

        revoke_request_payload = {
            'reason': cert_oper_params["reason"]
        }

        response = revoke_cert(revoke_request_url,
                               revoke_request_headers,
                               revoke_request_payload)

        if (('description' not in error_resp)
                and (response is not None)
                and (response.status_code >= 200)
                and (response.status_code < 300)):

            # Success
            logger.info("Revoke SSL certificate request successfully completed [sslId = " + str(
                cert_oper_params["sslId"]) + "]")

            return json.dumps({})

        elif ('description' not in error_resp) and (response is None):
            log_error_resp("", "Unknown Revoke error occurred.")
            raise SectigoException(json.dumps(error_resp))

        elif ('description' in error_resp) and (response is not None):
            err_msg = "Revoke error: error_resp={0}, response={1}, status_code={2}".format(
                error_resp, response, response.status_code)
            log_error_resp("", err_msg)
            raise SectigoException(json.dumps(error_resp))

        else:
            log_error_resp("", "Revoke error: error_resp={0}".format(error_resp))
            raise SectigoException(json.dumps(error_resp))

    except Exception as err:
        log_error_resp("", "Revoke error occurred: {}".format(str(err)))
        raise


def sect_enroll_client_cert(cert_oper_params):
    """
    API used to trigger the 'Enroll client certificate' operation.

    param, cert_oper_params - certificate parameter dictionary that contains
                            parameters required for this operation

    return - Requests response for the Collect operation
             None - if operation failed
    """
    global error_resp
    error_resp = {}

    logger.info("Proceeding to enroll client certificate...")

    do_parameter_validation = True

    # Get full path name of the csr if defined
    if 'csr' in cert_oper_params.keys() and cert_oper_params['csr'] and exists(cert_oper_params['csr']):
        do_parameter_validation = False

    try:
        if do_parameter_validation:
            if not are_enroll_client_cert_params_valid(cert_oper_params):
                raise ValueError('Enroll parameter validation failed')

        # Proceed with the new Sectigo certificate enroll request
        enroll_request_url = join(cert_oper_params["sectCABaseUrl"], str('enroll'))

        enroll_request_headers = {
            'login': cert_oper_params["login"],
            'password': cert_oper_params["password"],
            'customerUri': cert_oper_params["customerUri"]
        }

        # CSR value will be set in 'enrollSectigoCert()'
        enroll_request_payload = {
            'orgId': cert_oper_params["orgId"],
            'certType': cert_oper_params["certType"],
            'term': cert_oper_params["term"],
            'firstName': cert_oper_params["firstName"],
            'middleName': cert_oper_params["middleName"],
            'lastName': cert_oper_params["lastName"],
            'email': cert_oper_params["email"],
            'customFields': cert_oper_params["customFields"]
        }

        response = enroll_cert(cert_oper_params,
                               enroll_request_url,
                               enroll_request_headers,
                               enroll_request_payload)

        if (('description' not in error_resp)
                and (response is not None)
                and (response.status_code >= 200)
                and (response.status_code < 300)):

            # Success
            pyth_resp_content = json.loads(response.text)
            cert_order_number = pyth_resp_content["orderNumber"]

            logger.info("Enroll client certificate request successfully completed [orderNumber = " + str(
                cert_order_number) + "]")

            return response.text

        elif (response is None) and ('description' not in error_resp):
            # Valid certificate already exists, return its orderNumber from the IDS file
            cert_ids_file_full_path = join(cert_oper_params['certFilePath'], cert_ids_name)

            with open(cert_ids_file_full_path, 'r') as file:
                json_data = file.read()

                # Convert to a dictionary
                dict_data = json.loads(json_data)

                if "name" in dict_data:
                    # Remove the 'name' item
                    dict_data.pop("name")

                    # Convert back to JSON
                    json_data = json.dumps(dict_data)

            return str(json_data)

        elif (response is not None) and ('description' in error_resp):
            err_resp = "Enroll error: error_resp={0}, response={1}, status_code={2}".format(
                error_resp, response, response.status_code)
            log_error_resp("", err_resp)
            raise SectigoException(json.dumps(error_resp))

        else:
            err_resp = "Enroll error: error_resp={0}".format(error_resp)
            log_error_resp("", err_resp)
            raise SectigoException(json.dumps(error_resp))

    except Exception as err:
        log_error_resp("", "Enroll error occurred: {}".format(str(err)))
        raise


def sect_collect_client_cert(cert_oper_params):
    """
    API used to trigger the 'Collect client certificate' operation.

    param, cert_oper_params - certificate parameter dictionary that contains
                            parameters required for this operation

    return - Requests response for the Collect operation
             None - if operation failed
    """
    global error_resp
    error_resp = {}

    logger.info("Proceeding to collect client certificate...")

    try:
        # Check if provided parameters are valid
        if not are_collect_client_cert_params_valid(cert_oper_params):
            raise ValueError('Collect parameter validation failed')

        collect_request_url = """{sectCABaseUrl}/collect/{orderNumber}""".format(**cert_oper_params)

        # Error codes returned by the Sectigo server that are valid for waiting
        valid_waiting_err_codes = [0, -183, -1400]

        response = collect_cert(cert_oper_params, collect_request_url, valid_waiting_err_codes)

        if (('description' not in error_resp)
                and (response is not None)
                and (response.status_code >= 200)
                and (response.status_code < 300)):

            # Success
            cert_order_number = cert_oper_params["orderNumber"]

            logger.info("Collect client certificate request successfully completed [orderNumber = " + str(
                cert_order_number) + "]")
            return json.dumps({'certificate': response.text})

        elif ('description' not in error_resp) and (response is None):
            log_error_resp("", "Unknown Collect error occurred.")
            raise SectigoException(json.dumps(error_resp))

        elif ('description' in error_resp) and (response is not None):
            err_msg = "Collect error: error_resp={0}, response={1}, status_code={2}".format(
                error_resp, response, response.status_code)
            log_error_resp("", err_msg)
            raise SectigoException(json.dumps(error_resp))

        else:
            log_error_resp("", "Collect error: error_resp={0}".format(error_resp))
            raise SectigoException(json.dumps(error_resp))

    except Exception as err:
        log_error_resp("", "Collect error occurred: {}".format(str(err)))
        raise

def sect_renew_client_cert(cert_oper_params):
    """
    API used to trigger the 'Renew client certificate' operation.

    param, cert_oper_params - certificate parameter dictionary that contains
                            parameters required for this operation

    return - Requests response for the Collect operation
             None - if operation failed
    """
    global error_resp
    error_resp = {}

    logger.info("Proceeding to renew client certificate...")

    try:
        # Proceed with the new Sectigo certificate renew request
        renew_request_url = join(cert_oper_params["sectCABaseUrl"], str('renew/order/'))
        renew_request_url = renew_request_url.replace("v1", "v2")

        renew_request_headers = {
            'login': cert_oper_params["login"],
            'password': cert_oper_params["password"],
            'customerUri': cert_oper_params["customerUri"]
        }

        renew_request_payload = {
        }

        response = renew_cert(cert_oper_params,
                               renew_request_url,
                               renew_request_headers,
                               renew_request_payload)

        if (('description' not in error_resp)
                and (response is not None)
                and (response.status_code >= 200)
                and (response.status_code < 300)):

            # Success
            pyth_resp_content = json.loads(response.text)
            cert_order_number = pyth_resp_content["orderNumber"]

            logger.info("Renew client certificate request successfully completed [orderNumber = " + str(
                cert_order_number) + "]")

            return response.text

        elif (response is not None) and ('description' in error_resp):
            err_resp = "Renew error: error_resp={0}, response={1}, status_code={2}".format(
                error_resp, response, response.status_code)
            log_error_resp("", err_resp)
            raise SectigoException(json.dumps(error_resp))

        else:
            err_resp = "Renew error: error_resp={0}".format(error_resp)
            log_error_resp("", err_resp)
            raise SectigoException(json.dumps(error_resp))

    except Exception as err:
        log_error_resp("", "Renew error occurred: {}".format(str(err)))
        raise

def sect_revoke_client_cert(cert_oper_params):
    """
    API used to trigger the 'Revoke client certificate' operation.

    param, cert_oper_params - certificate parameter dictionary that contains
                              parameters required for this operation

    return - Requests response for the Revoke operation
             None - if operation failed
    """
    global error_resp
    error_resp = {}

    logger.info("Proceeding to revoke client certificate...")

    try:
        # Check if provided parameters are valid
        if not are_revoke_client_cert_params_valid(cert_oper_params):
            raise ValueError('Revoke parameter validation failed')

        revoke_request_url = """{sectCABaseUrl}/revoke/order/{orderNumber}""".format(**cert_oper_params)

        revoke_request_headers = {
            'login': cert_oper_params["login"],
            'password': cert_oper_params["password"],
            'customerUri': cert_oper_params["customerUri"]
        }

        revoke_request_payload = {
            'reason': cert_oper_params["reason"]
        }

        response = revoke_cert(revoke_request_url,
                               revoke_request_headers,
                               revoke_request_payload)

        if (('description' not in error_resp)
                and (response is not None)
                and (response.status_code >= 200)
                and (response.status_code < 300)):

            # Success
            logger.info("Revoke client certificate request successfully completed [orderNumber = " + str(
                cert_oper_params["orderNumber"]) + "]")

            return json.dumps({})

        elif ('description' not in error_resp) and (response is None):
            log_error_resp("", "Unknown Revoke error occurred.")
            raise SectigoException(json.dumps(error_resp))

        elif ('description' in error_resp) and (response is not None):
            err_msg = "Revoke error: error_resp={0}, response={1}, status_code={2}".format(
                error_resp, response, response.status_code)
            log_error_resp("", err_msg)
            raise SectigoException(json.dumps(error_resp))

        else:
            log_error_resp("", "Revoke error: error_resp={0}".format(error_resp))
            raise SectigoException(json.dumps(error_resp))

    except Exception as err:
        log_error_resp("", "Revoke error occurred: {}".format(str(err)))
        raise


def test_create_ids_file(cert_oper_params, cert_sslid):
    ids_file_full_path = join(cert_oper_params["certFilePath"], cert_oper_params["certFileName"])

    # Prepare data to be writen to the file
    dict_data = {"sslId": cert_sslid}

    # Delete IDS file (if exists)
    if exists(ids_file_full_path):
        os.remove(ids_file_full_path)

    # Create an empty IDS file
    # open(ids_file_full_path + ".ids", "w")

    # Write data in JSON format to file
    with open(ids_file_full_path + ".ids", 'w') as outfile:
        json.dump(dict_data, outfile)


def main():
    """
    Used for testing purpose
    """
    global cert_crt_name
    global cert_csr_name
    global cert_key_name

    global max_timeout
    global loop_period

    if len(sys.argv) != 2:
        logger.info("Please provide config file. Syntax: python <sectigo-ssl-entrypoint.py> <sectigo-ssl-config.txt>")
        sys.exit(-1)

    else:
        logger.info("Initiating Sectigo Certificate validation and procurement process...")

        params_file_name = sys.argv[1]
        full_file_path = os.path.realpath(params_file_name)
        params_file_path, params_file_name = os.path.split(full_file_path)

        # 1. Check param file path and the file exists
        check_params_file_response = does_file_exist(params_file_path, params_file_name)

        if check_params_file_response:

            try:

                # --------------- #
                # SSL certificate #
                # --------------- #

                cert_ssl_enroll_params = {

                    'sectCABaseUrl': 'https://myca.cert-manager.com/api/ssl/v1',
                    'certDomain': 'test1.myorg.com',
                    'certSubject': 'C=CA/ST=ON/L=Ottawa/O=MyOrg/OU=Research/CN=test1.myorg.com/'
                                   'emailAddress=example@myorg.com',
                    'login': 'myuser',
                    'password': 'mypass',
                    'customerUri': 'myuri',
                    'orgId': 123,
                    'certFilePath': './certificates',
                    'certFileName': 'test_ssl',
                    'certType': 42,
                    'term': 365,
                    'comments': 'Test Certificate',
                    'externalRequester': '',
                    'subjAltNames': '',
                    'numberServers': 0,
                    'customFields': '',
                    'serverType': -1,
                    'force': False,
                    'expiryWindow': 7,
                    'autoRenew': True,
                    'formatType': 'base64',
                    'maxTimeout': 600,
                    'loopPeriod': 30
                }

                resp = sect_enroll_ssl_cert(cert_ssl_enroll_params)

                if 'description' in resp:
                    print(str(resp))
                    exit(0)

                pyth_resp_content = json.loads(resp)
                cert_sslid = pyth_resp_content["sslId"]

                print(resp)

            except SectigoException as exc:
                logger.error("\nAn error occurred: {}".format(exc))

        else:
            logger.info("Parameter file not found. Please try again.")


if __name__ == "__main__":
    main()
